---
title: "portfolio_3"
author: "Niels Aalund Krogsgaard"
date: "2024-03-21"
output: pdf_document
---

```{r installing}
pacman::p_load(tidyverse,
               here,
               posterior,
               cmdstanr,
               brms, 
               tidybayes, 
               loo)
```


```{r compiling model}
# Compiling model
simple_model <- cmdstan_model("simple_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
# 
# weighted_model <- cmdstan_model("weighted_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r simulation}
SimpleBayes_f <- function(bias, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

bias <- 2
trials <- seq(10)
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(bias = bias, trials = trials, Source1 = Source1, Source2 = Source2)

for (n in seq(nrow(db))) {
  db$belief[n] <- SimpleBayes_f(db$bias[n], db$Source1[n], db$Source2[n])
  db$choice[n] <- rbinom(1,1, db$belief[n])
  db$continuous[n] <- (db$belief[n]*8)
  db$discrete[n] <- round((db$belief[n]*8),0)
}
```

```{r noise and rate}
data_simpleBayes <- list(
  trials = nrow(db),
  first_rating = db$Source1,
  other_rating = db$Source2,
  second_rating = db$choice
  )
```

```{r data}
# Create the data

```

```{r modeling, message=FALSE, warning=FALSE}
samples <- simple_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains = 2,
   parallel_chains = 2,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```


```{r summary}
# Summary

samples$summary()

samples$cmdstan_diagnose()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = inv_logit_scaled(db$bias[1])) +
  theme_bw()
```

```{r visualisations}
# Visualisations for prior posterior updates

# Extract posterior samples and include sampling of the prior:
draws_df <- as_draws_df(samples$draws())

# Now let's plot the density for theta (prior and posterior)
prior_plot_1 <- ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(rate)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(rate_prior)), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = inv_logit_scaled(rate)) +
  xlab("Rate (Probability Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Rate", subtitle = "Black line indicates true value")

prior_plot_2 <- ggplot(draws_df) +
  geom_density(aes(rate), fill = "blue", alpha = 0.3) +
  geom_density(aes(rate_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = rate) +
  xlab("Rate (Log space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Rate", subtitle = "Black line indicates true value")

prior_plot_3 <- ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(betaGamble)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(betaGamble_prior)), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = inv_logit_scaled(betagamble)) +
  xlab("Beta Gamble (Probability Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for BetaGamble", subtitle = "Black line indicates true value")

prior_plot_4 <- ggplot(draws_df) +
  geom_density(aes(betaGamble), fill = "blue", alpha = 0.3) +
  geom_density(aes(betaGamble_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = betagamble) +
  xlab("Beta Gamble (Log space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for BetaGamble", subtitle = "Black line indicates true value")

# ggplot(draws_df) +
#   geom_density(aes(rate_prior), fill = "blue", alpha = 0.3) +
#   #geom_density(aes(betaGamble_prior), fill = "red", alpha = 0.3) +
#   #geom_vline(xintercept = betagamble) +
#   #xlab("Beta Gamble") +
#   ylab("Posterior Density") +
#   theme_classic() +
#   lims(x = c(-2.5,2.5))
# 
# ggplot(draws_df) +
#   geom_density(aes(betaGamble_prior), fill = "blue", alpha = 0.3) +
#   #geom_density(aes(betaGamble_prior), fill = "red", alpha = 0.3) +
#   #geom_vline(xintercept = betagamble) +
#   #xlab("Beta Gamble") +
#   ylab("Posterior Density") +
#   theme_classic()  +
#   lims(x = c(-2.5,2.5))

prior_plot_1
prior_plot_2
prior_plot_3
prior_plot_4

ggsave(filename = "figures/prior_plot_rate.png", plot = prior_plot_1)
ggsave(filename = "figures/prior_plot_rate_log.png", plot = prior_plot_2)
ggsave(filename = "figures/prior_plot_betagamble.png", plot = prior_plot_3)
ggsave(filename = "figures/prior_plot_betagamble_log.png", plot = prior_plot_4)
```

```{r prior posterior prediction checks}
print(draws_df)

prior_preds <- numeric(trials)

#prior_preds <- rowMeans(draws_df[,126:246])

for (i in 1:trials){
  prior_preds[i] <- mean(draws_df[[125+i]])
}

posterior_preds <- numeric(trials)

#posterior_preds <- rowMeans(draws_df[,246:366])

for (i in 1:trials){
  posterior_preds[i] <- mean(draws_df[[245+i]])
}

# Prior predictions
predictions_prior_plot <- ggplot() +
  geom_histogram(aes(prior_preds), color = "darkblue", fill = "blue", alpha = 0.3, binwidth = 0.002) +
  xlab("The predicted proportion of choosing the right hand out of 120 trials") +
  ylab("Counts") +
  theme_classic()

# Posterior predictions
predictions_posterior_plot <- ggplot() +
  geom_histogram(aes(posterior_preds), color = "darkblue", fill = "blue", alpha = 0.3, binwidth = 0.002) +
  #geom_vline(x = mean(data$choice)) +
  # #geom_point(x = mean(data$choice), y = 0, color = "red", shape = 17, size = 5) +
  xlab("The predicted proportion of choosing the right hand out of 120 trials") +
  ylab("Counts") +
  theme_classic()

predictions_prior_plot
predictions_posterior_plot

ggsave(filename = "figures/prior_predictions.png", plot = predictions_prior_plot)
ggsave(filename = "figures/posterior_predictions.png", plot = predictions_posterior_plot)
```

```{r model quality}
# Model quality check

samples$cmdstan_diagnose()

diagnostics_caterpillar_plot <- ggplot(draws_df, aes(.iteration, rate, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggsave(filename = "figures/caterpillar.png", plot = diagnostics_caterpillar_plot)
```

```{r parameter recovery}
# Parameter recovery

# Now we need to scale it up to all possible rates and noises
recovery_df <- NULL

for (noiseLvl in seq(0, 0.5, 0.1)) { # Looping through noise levels
  for (rateLvl in c(-5,-3,-1,-0.5,0,0.5,1,3,5)) { # Looping through rate levels
    for (beta_g in c(-10,-5,-1,-0.5,0,0.5,1,5,10)) {
      for (n_trials in c(12,120,1200)) {
        # Generate list of choices
        outcome <- WinLoseResults_model_f(n_trials, noiseLvl, rateLvl, betagamble = beta_g)
      
        # Create data for model
        data <- list(
          trials = n_trials,
          success = outcome$feedback,
          choice = outcome$choice
        )
        
        samples <- portfolio2_model$sample(
          data = data,
          #seed = 123,
          chains = 1,
          parallel_chains = 1,
          threads_per_chain = 1,
          iter_warmup = 1000,
          iter_sampling = 2000,
          refresh = 0,
          max_treedepth = 20,
          adapt_delta = 0.99,
        )
        
        draws_df <- as_draws_df(samples$draws()) 
        temp <- tibble(rate_est = mean(inv_logit_scaled(draws_df$rate)), 
                       rate_true = rateLvl,
                       beta_g_est = mean(inv_logit_scaled(draws_df$betaGamble)),
                       beta_g_true = beta_g,
                       noise = noiseLvl,
                       trials = n_trials)
        
        
        if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
      }
    }
  }
}

write_csv(recovery_df, "simdata/W3_recoverydf_alternative_trials.csv")
```


```{r visualising pr}
recovery_df <- read_csv("simdata/W3_recoverydf_alternative_trials.csv")

param_recov_rate_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(rate_est, inv_logit_scaled(rate_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw() +
  labs(x = "Estimated Rate", y = "True Rate", title = "Parameter Recovery For Different Levels of Noise: Rate", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_betag_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(beta_g_est, inv_logit_scaled(beta_g_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw()+
  labs(x = "Estimated BetaGamble", y = "True BetaGamble", title = "Parameter Recovery For Different Levels of Noise: BetaGamble", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_rate_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(rate_est, inv_logit_scaled(rate_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw() +
  labs(x = "Estimated Rate", y = "True Rate", title = "Parameter Recovery For Different Levels of Noise: Rate", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_betag_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(beta_g_est, inv_logit_scaled(beta_g_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw()+
  labs(x = "Estimated BetaGamble", y = "True BetaGamble", title = "Parameter Recovery For Different Levels of Noise: BetaGamble", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_rate_1200 <- recovery_df %>% 
  filter(trials == 1200) %>% 
  ggplot(aes(rate_est, inv_logit_scaled(rate_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw() +
  labs(x = "Estimated Rate", y = "True Rate", title = "Parameter Recovery For Different Levels of Noise: Rate", subtitle = "For 1200 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_betag_1200 <- recovery_df %>% 
  filter(trials == 1200) %>% 
  ggplot(aes(beta_g_est, inv_logit_scaled(beta_g_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~noise) +
  theme_bw()+
  labs(x = "Estimated BetaGamble", y = "True BetaGamble", title = "Parameter Recovery For Different Levels of Noise: BetaGamble", subtitle = "For 1200 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_rate_12
param_recov_rate_120
param_recov_rate_1200
param_recov_betag_12
param_recov_betag_120
param_recov_betag_1200

ggsave(filename = "figures/param_recov_rate_12.png", plot = param_recov_rate_12)
ggsave(filename = "figures/param_recov_rate_120.png", plot = param_recov_rate_120)
ggsave(filename = "figures/param_recov_rate_1200.png", plot = param_recov_rate_1200)
ggsave(filename = "figures/param_recov_betagamble_12.png", plot = param_recov_betag_12)
ggsave(filename = "figures/param_recov_betagamble_120.png", plot = param_recov_betag_120)
ggsave(filename = "figures/param_recov_betagamble_1200.png", plot = param_recov_betag_1200)
```

## Loading data
```{r compiling model}
# Compiling model
simple_model_poisson <- cmdstan_model("simple_bayesian_poisson.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
# 
# weighted_model <- cmdstan_model("weighted_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r loading and investigating data}
df_real <- read_csv("data/cogsci_clean.csv")

df_real_1 <- df_real %>% 
  filter(ID == 1) %>%
  filter(GroupRating != 0) %>% 
  select(FirstRating, GroupRating, SecondRating) %>% 
    mutate(FirstRating_new = FirstRating-4.5, 
           GroupRating_new = GroupRating-4.5,
           Choice = SecondRating-1)
  
  data_simpleBayes_temp <- list(
  trials = nrow(temp),
  first_rating = temp$FirstRating_new,
  other_rating = temp$GroupRating_new,
  second_rating = temp$Choice
  )

samples <- simple_model_poisson$sample(
   data = data_simpleBayes_poisson_1,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```


```{r}
samples$summary()

samples$cmdstan_diagnose()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(bias), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(bias_prior), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
  theme_bw()
```
### The great for-loop
```{r}
simple_model <- cmdstan_model("simple_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

df_real <- read_csv("data/cogsci_clean.csv")

prior_post_plots <- list()
cat_bias_plot <- list()

for (i in 1:n_distinct(df_real$ID)){
  temp <- df_real %>% 
    filter(ID == unique(df_real$ID)[i]) %>%
    filter(GroupRating != 0) %>% 
    select(FirstRating, GroupRating, SecondRating) %>% 
    mutate(FirstRating_new = FirstRating/9, 
           GroupRating_new = GroupRating/9,
           Choice = ifelse(SecondRating > 4, 1, 0))
  
  data_simpleBayes_temp <- list(
  trials = nrow(temp),
  first_rating = temp$FirstRating_new,
  other_rating = temp$GroupRating_new,
  second_rating = temp$Choice
  )

  samples <- simple_model$sample(
     data = data_simpleBayes_temp,
     seed = 123,
     chains =4,
     parallel_chains = 4,
     threads_per_chain = 2,
     iter_warmup = 2000,
     iter_sampling = 2000,
     refresh = 500,
     max_treedepth = 20,
     adapt_delta = 0.99,
  )
  
  draws_df <- as_draws_df(samples$draws()) 
  
  prior_post_plots[[i]] <- ggplot(draws_df) +
    geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
    geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
    theme_bw() +
    ggtitle(paste("Participant", i))
    # temp <- tibble(bias_est = mean(inv_logit_scaled(draws_df$bias)))
    # if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
  
  cat_bias_plot[[i]] <- ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
}


prior_post_plots
cat_bias_plot
```


## Multi-level model

```{r compiling model}

# Compiling model
simple_multi_model <- cmdstan_model("simple_multi_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

```

```{r fake data}
SimpleBayes_f <- function(bias, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

# agents <- 10
# agents_list <- seq(10)
# biasM <- 1
# biasSD <- 0.2
# trials <- 10
# trials_list <- seq(trials)
# Source1 <- seq(0.1,0.9, 0.1)
# Source2 <- seq(0.1,0.9, 0.1)
# z_bias <- rnorm(agents, biasM, biasSD)

# db <- expand.grid(trials = trials_list, agents = agents_list, Source1 = Source1, Source2 = Source2)
# 
# db <- expand.grid(Source1 = Source1, Source2 = Source2)
# 
# for (n in seq(nrow(db))) {
#   db$belief[n] <- SimpleBayes_f(db$z_bias[n], db$Source1[n], db$Source2[n])
  # db$choice[n] <- rbinom(1,1, db$belief[n])
  # db$continuous[n] <- (db$belief[n]*8)
  # db$discrete[n] <- round((db$belief[n]*8),0)
# }

# Looping through all the agents to generate the data.
d <- NULL
biasM <- 2
biasSD <- 0.1
agents <- 10
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(Source1 = Source1, Source2 = Source2)

for (agent in 1:agents) {
  
  bias <- rnorm(1, biasM, biasM)
  
  belief <- rep(NA, nrow(db))
  choice <- rep(NA, nrow(db))
  continuous <- rep(NA, nrow(db))
  discrete <- rep(NA, nrow(db))
  
  for (n in seq(nrow(db))) {
    
    belief[n] <- SimpleBayes_f(bias, db[n,1], db[n,2])
    choice[n] <- rbinom(1,1, belief[n])
    continuous[n] <- (belief[n]*8)
    discrete[n] <- round((belief[n]*8),0)
  }
  
  temp <- tibble(agent, trial = seq(nrow(db)), source1 = db[,1], source2 = db[,2],  belief, choice, bias, biasM, biasSD, continuous, discrete)
  
  if (agent > 1) {
    d <- rbind(d, temp)
  } else{
    d <- temp
  }
  
}
```


```{r}
df_first_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source1) %>%
  pivot_wider(values_from = source1, names_from = agent) %>% 
  select(-trial)

df_group_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source2) %>%
  pivot_wider(values_from = source2, names_from = agent) %>% 
  select(-trial)

df_second_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, choice) %>%
  pivot_wider(values_from = choice, names_from = agent) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (d %>% filter(agent == 1) %>% nrow()),
  subjects = n_distinct(d$agent),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- simple_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```
```{r}
samples$summary()
```
```{r}
draws_df <- as_draws_df(samples$draws())

samples$cmdstan_diagnose()

ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```



```{r data}
df_real <- read_csv("data/cogsci_clean.csv")

df_real <- df_real %>% 
  filter(GroupRating != 0) %>% 
  select(ID,FaceID, FirstRating, GroupRating, SecondRating) %>% 
  mutate(FirstRating_new = FirstRating/9, 
         GroupRating_new = GroupRating/9,
         Choice = ifelse(SecondRating > 4, 1, 0))

# the problem here is that the trial does not correspond to the same FaceID

df_first_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, FirstRating_new) %>%
  pivot_wider(values_from = FirstRating_new, names_from = ID) %>% 
  select(-trial)

df_group_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, GroupRating_new) %>%
  pivot_wider(values_from = GroupRating_new, names_from = ID) %>% 
  select(-trial)

df_second_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, Choice) %>%
  pivot_wider(values_from = Choice, names_from = ID) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (df_real %>% filter(ID == 1) %>% nrow()),
  subjects = n_distinct(df_real$ID),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- simple_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```

```{r}
samples$summary()
```
```{r}
ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```


```{r model quality}
# Model quality check
draws_df <- as_draws_df(samples$draws())

samples$cmdstan_diagnose()

diagnostics_caterpillar_plot_biasm <- ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

diagnostics_caterpillar_plot_biassd <- ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggsave(filename = "figures/caterpillar_biasM.png", plot = diagnostics_caterpillar_plot_biasm)

ggsave(filename = "figures/caterpillar_biasSD.png", plot = diagnostics_caterpillar_plot_biassd)
```

```{r}
# the problem here is that the trial does not correspond to the same FaceID


# df_real %>% select(ID, FirstRating) %>%
#   pivot_wider(values_from = FirstRating, names_from = ID)
```


