---
title: "portfolio_3"
author: "Niels Aalund Krogsgaard"
date: "2024-03-21"
output: pdf_document
---

```{r installing}
pacman::p_load(tidyverse,
               here,
               posterior,
               cmdstanr,
               brms, 
               tidybayes, 
               loo)
```


```{r compiling model}
# Compiling model
simple_model <- cmdstan_model("simple_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
# 
weighted_model <- cmdstan_model("weighted_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r simulation}
SimpleBayes_f <- function(bias, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + 0.5 * logit_scaled(Source1) + 0.5 * logit_scaled(Source2))
  # outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

bias <- -0.5
trials <- seq(10)
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(bias = bias, trials = trials, Source1 = Source1, Source2 = Source2)

for (n in seq(nrow(db))) {
  db$belief[n] <- SimpleBayes_f(db$bias[n], db$Source1[n], db$Source2[n])
  db$choice[n] <- rbinom(1,1, db$belief[n])
  db$continuous[n] <- (db$belief[n]*8)
  db$discrete[n] <- round((db$belief[n]*8),0)
}

data_simpleBayes <- list(
  trials = nrow(db),
  first_rating = db$Source1,
  other_rating = db$Source2,
  second_rating = db$choice
  )

samples <- simple_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains = 2,
   parallel_chains = 2,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```

```{r summary}
# Summary
samples$summary()

samples$cmdstan_diagnose()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = inv_logit_scaled(db$bias[1])) +
  theme_bw()
```

```{r visualisations}
# Visualisations for prior posterior updates

# Extract posterior samples and include sampling of the prior:
draws_df <- as_draws_df(samples$draws())

# Now let's plot the density for theta (prior and posterior)
prior_plot_1 <- ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(bias)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(bias_prior)), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = inv_logit_scaled(bias)) +
  xlab("Rate (Probability Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

prior_plot_2 <- ggplot(draws_df) +
  geom_density(aes(bias), fill = "blue", alpha = 0.3) +
  geom_density(aes(bias_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = bias) +
  xlab("Rate (Log space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

prior_plot_1
prior_plot_2

ggsave(filename = "figures/simple/prior_plot_bias.png", plot = prior_plot_1)
ggsave(filename = "figures/simple/prior_plot_bias_log.png", plot = prior_plot_2)
```

```{r model quality}
# Model quality check

samples$cmdstan_diagnose()

diagnostics_caterpillar_plot <- ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

diagnostics_caterpillar_plot

ggsave(filename = "figures/simple/caterpillar.png", plot = diagnostics_caterpillar_plot)
```

```{r parameter recovery}
# Parameter recovery

# Now we need to scale it up to all possible rates and noises
recovery_df <- NULL

for (bias_i in c(-5,-3,-1,-0.5,0,0.5,1,3,5)) { # Looping through rate levels
  for (n_trials in c(12,120,1200)) {
  
    Source1 <- seq(0.1,0.9, 0.1)
    Source2 <- seq(0.1,0.9, 0.1)

    db <- expand.grid(bias = bias_i, trials = n_trials, Source1 = Source1, Source2 = Source2)

    for (n in seq(nrow(db))) {
      db$belief[n] <- SimpleBayes_f(db$bias[n], db$Source1[n], db$Source2[n])
      db$choice[n] <- rbinom(1,1, db$belief[n])
      }

    data_simpleBayes <- list(
      trials = nrow(db),
      first_rating = db$Source1,
      other_rating = db$Source2,
      second_rating = db$choice
      )
        
    samples <- simple_model$sample(
       data = data_simpleBayes,
       seed = 123,
       chains = 2,
       parallel_chains = 2,
       threads_per_chain = 2,
       iter_warmup = 2000,
       iter_sampling = 2000,
       refresh = 500,
       max_treedepth = 20,
       adapt_delta = 0.99,
    )
        
    
    draws_df <- as_draws_df(samples$draws()) 
    
    temp <- tibble(bias_est = mean((draws_df$bias)), 
                   bias_true = bias_i,
                   trials = n_trials)
    
    if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
  }
}

write_csv(recovery_df, "simdata/recoverydf_simple.csv")
```


```{r visualising pr}
recovery_df <- read_csv("simdata/recoverydf_simple.csv")

param_recov_bias_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(inv_logit_scaled(bias_est), inv_logit_scaled(bias_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_bias_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(inv_logit_scaled(bias_est), inv_logit_scaled(bias_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_bias_1200 <- recovery_df %>% 
  filter(trials == 1200) %>% 
  ggplot(aes(inv_logit_scaled(bias_est), inv_logit_scaled(bias_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 1200 trials") +
  lims(x = c(0,1), y = c(-0.1,1))

param_recov_bias_12
param_recov_bias_120
param_recov_bias_1200

ggsave(filename = "figures/simple/param_recov_bias_12.png", plot = param_recov_bias_12)
ggsave(filename = "figures/simple/param_recov_bias_120.png", plot = param_recov_bias_120)
ggsave(filename = "figures/simple/param_recov_bias_1200.png", plot = param_recov_bias_1200)
```

## Weighted model
```{r}
weighted_model <- cmdstan_model("weighted_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r}
WeightedBayes_f <- function(bias, weight1, weight2, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + weight1 * logit_scaled(Source1) + weight2 * logit_scaled(Source2))
  # outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

bias_val <- -0.5
weight1_val <- 0.7
weight2_val <- 0.2
trials <- seq(10)
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(bias = bias, trials = trials, weight1 = weight1, weight2 = weight2, Source1 = Source1, Source2 = Source2)

for (n in seq(nrow(db))) {
  db$belief[n] <- WeightedBayes_f(db$bias[n], db$weight1[n], db$weight2[n] , db$Source1[n], db$Source2[n])
  db$choice[n] <- rbinom(1,1, db$belief[n])
}

data_weightedBayes <- list(
  trials = nrow(db),
  first_rating = db$Source1,
  other_rating = db$Source2,
  second_rating = db$choice
  )

samples <- weighted_model$sample(
   data = data_weightedBayes,
   seed = 123,
   chains = 2,
   parallel_chains = 2,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```

```{r}
# Summary
samples$summary()

samples$cmdstan_diagnose()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = inv_logit_scaled(bias_val)) +
  theme_bw()

ggplot(draws_df) +
  geom_density(aes(weight1), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(weight1_prior), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weight1_val) +
  theme_bw()

ggplot(draws_df) +
  geom_density(aes(weight2), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(weight2_prior), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weight2_val) +
  theme_bw()

```

### The great for-loop

```{r}
# Parameter recovery

# Now we need to scale it up to all possible rates and noises
recovery_df <- NULL

for (bias_i in c(-5,-3,-1,-0.5,0,0.5,1,3,5)) { # Looping through rate levels
  for (n_trials in c(12,120)) {
    for (w1 in c(seq(0.1,0.9,0.2))) {
      for (w2 in c(seq(0.1,0.9,0.2))) {
  
        Source1 <- seq(0.1,0.9, 0.1)
        Source2 <- seq(0.1,0.9, 0.1)
    
        db <- expand.grid(bias = bias_i, trials = n_trials, weight1 = w1, weight2 = w2, Source1 = Source1, Source2 = Source2)
    
        for (n in seq(nrow(db))) {
          db$belief[n] <- WeightedBayes_f(db$bias[n], db$weight1[n], db$weight2[n], db$Source1[n], db$Source2[n])
          db$choice[n] <- rbinom(1,1, db$belief[n])
          }
    
        data_weightedBayes <- list(
          trials = nrow(db),
          first_rating = db$Source1,
          other_rating = db$Source2,
          second_rating = db$choice
          )
            
        samples <- weighted_model$sample(
           data = data_weightedBayes,
           seed = 123,
           chains = 2,
           parallel_chains = 2,
           threads_per_chain = 2,
           iter_warmup = 2000,
           iter_sampling = 2000,
           refresh = 500,
           max_treedepth = 20,
           adapt_delta = 0.99,
        )
            
        
        draws_df <- as_draws_df(samples$draws()) 
        
        temp <- tibble(bias_est = mean((draws_df$bias)), 
                       bias_true = bias_i,
                       weight1_est = mean(draws_df$weight1),
                       weight1_true = w1,
                       weight2_est = mean(draws_df$weight2),
                       weight2_true = w2,
                       trials = n_trials)
        
        if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
      }
    }
  }
}

write_csv(recovery_df, "simdata/recoverydf_weighted.csv")
```

```{r}
recovery_df <- read_csv("simdata/recoverydf_weighted.csv")

param_recov_bias_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(inv_logit_scaled(bias_est), inv_logit_scaled(bias_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_bias_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(inv_logit_scaled(bias_est), inv_logit_scaled(bias_true))) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_w1_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(weight1_est, weight1_true)) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~bias_true) +
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_w1_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(weight1_est, weight1_true)) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~bias_true) +
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_w2_12 <- recovery_df %>% 
  filter(trials == 12) %>% 
  ggplot(aes(weight2_est, weight2_true)) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~bias_true) +
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 12 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_w2_120 <- recovery_df %>% 
  filter(trials == 120) %>% 
  ggplot(aes(weight2_est, weight2_true)) +
  geom_point(alpha = 0.3) +
  geom_smooth() +
  geom_abline(intercept = 0,slope=1)+
  facet_wrap(.~bias_true) +
  theme_bw() +
  labs(x = "Estimated Bias", y = "True Bias", title = "Parameter Recovery For Different Levels of Noise: Bias", subtitle = "For 120 trials") +
  lims(x = c(0,1), y = c(0,1))

param_recov_bias_12
param_recov_bias_120
param_recov_w1_12
param_recov_w1_120
param_recov_w2_12
param_recov_w2_120

# ggsave(filename = "figures/param_recov_rate_12.png", plot = param_recov_rate_12)
# ggsave(filename = "figures/param_recov_rate_120.png", plot = param_recov_rate_120)
# ggsave(filename = "figures/param_recov_rate_1200.png", plot = param_recov_rate_1200)
# ggsave(filename = "figures/param_recov_betagamble_12.png", plot = param_recov_betag_12)
# ggsave(filename = "figures/param_recov_betagamble_120.png", plot = param_recov_betag_120)
# ggsave(filename = "figures/param_recov_betagamble_1200.png", plot = param_recov_betag_1200)
```



## Loading data
```{r compiling model}
# Compiling model
simple_model <- cmdstan_model("simple_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
# 
weighted_model <- cmdstan_model("weighted_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r loading and investigating data}
df_real <- read_csv("data/cogsci_clean.csv")

df_real %>% 
  ggplot()+
  geom_histogram(aes(x = FirstRating)) +
  ggtitle("FirstRating")

df_real %>% 
  filter(GroupRating != 0) %>% 
  ggplot()+
  geom_histogram(aes(x = GroupRating)) +
  ggtitle("GroupRating")

df_real %>% 
  ggplot()+
  geom_histogram(aes(x = SecondRating)) +
  ggtitle("SecondRating")

df_real %>% 
  ggplot()+
  geom_histogram(aes(x = FirstRating, y=after_stat(density))) +
  ggtitle(paste("FirstRating", round(mean(df_real$FirstRating), 2)))

df_real %>% 
  filter(GroupRating != 0) %>% 
  ggplot()+
  geom_histogram(aes(x = GroupRating, y=after_stat(density))) +
  ggtitle(paste("GroupRating", round(mean(df_real$GroupRating), 2)))

df_real %>% 
  ggplot()+
  geom_histogram(aes(x = SecondRating, y=after_stat(density))) +
  ggtitle(paste("SecondRating", round(mean(df_real$SecondRating), 2)))

df_real %>% 
  group_by(FaceID) %>% 
  summarise("sum_first" = mean(FirstRating)) %>% 
  ggplot(aes(x = FaceID, y = sum_first)) +
  geom_bar(stat="identity",fill="Red") +
  geom_hline(yintercept = 4.5)

df_real %>% 
  group_by(FaceID) %>% 
  summarise("sum_group" = mean(GroupRating)) %>% 
  ggplot(aes(x = FaceID, y = sum_group)) +
  geom_bar(stat="identity",fill="Red") +
  geom_hline(yintercept = 4.5)

df_real %>% 
  group_by(FaceID) %>% 
  summarise("sum_second" = mean(SecondRating)) %>% 
  ggplot(aes(x = FaceID, y = sum_second)) +
  geom_bar(stat="identity",fill="Red") +
  geom_hline(yintercept = 4.5)
```


```{r filtering for participant 1}
df_real_1 <- df_real %>% 
  filter(ID == 1) %>%
  filter(GroupRating != 0) %>% 
  select(FirstRating, GroupRating, SecondRating) %>% 
  mutate(FirstRating_new = FirstRating/9, 
         GroupRating_new = GroupRating/9,
         Choice = ifelse(SecondRating > 4, 1, 0))

```

```{r fitting model}
data_simpleBayes_1 <- list(
  trials = nrow(df_real_1),
  first_rating = df_real_1$FirstRating_new,
  other_rating = df_real_1$GroupRating_new,
  second_rating = df_real_1$Choice
  )

samples_simple <- simple_model$sample(
   data = data_simpleBayes_1,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)

samples_weighted <- weighted_model$sample(
   data = data_simpleBayes_1,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```

```{r}
samples_simple$summary()

samples_weighted$summary()

samples_simple$cmdstan_diagnose()
samples_weighted$cmdstan_diagnose()

draws_df_simple <- as_draws_df(samples_simple$draws())
draws_df_weighted <- as_draws_df(samples_weighted$draws())

ggplot(draws_df_simple) +
  geom_density(aes(bias), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(bias_prior), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df_weighted) +
  geom_density(aes(bias), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(bias_prior), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df_weighted) +
  geom_density(aes(weight1), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(weight1_prior), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df_weighted) +
  geom_density(aes(weight2), alpha = 0.6, fill = "lightblue") +
  geom_density(aes(weight2_prior), alpha = 0.6, fill = "pink") +
  theme_bw()
```


### The great for-loop
```{r}
simple_model <- cmdstan_model("simple_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

df_real <- read_csv("data/cogsci_clean.csv")

prior_post_plots <- list()
cat_bias_plot <- list()

if (exists("bias_participants")) {rm(bias_participants)}

for (i in 1:n_distinct(df_real$ID)){
  temp <- df_real %>% 
    filter(ID == unique(df_real$ID)[i]) %>%
    filter(GroupRating != 0) %>% 
    select(FirstRating, GroupRating, SecondRating) %>% 
    mutate(FirstRating_new = FirstRating/9, 
           GroupRating_new = GroupRating/9,
           Choice = ifelse(SecondRating > 4, 1, 0))
  
  data_simpleBayes_temp <- list(
  trials = nrow(temp),
  first_rating = temp$FirstRating_new,
  other_rating = temp$GroupRating_new,
  second_rating = temp$Choice
  )

  samples <- simple_model$sample(
     data = data_simpleBayes_temp,
     seed = 123,
     chains =4,
     parallel_chains = 4,
     threads_per_chain = 2,
     iter_warmup = 2000,
     iter_sampling = 2000,
     refresh = 500,
     max_treedepth = 20,
     adapt_delta = 0.99,
  )
  
  draws_df <- as_draws_df(samples$draws())
  
  temp <- tibble(bias_est = draws_df$bias)
  colnames(temp)[1] <- paste0("bias_est_", i)
    
  if (exists("bias_participants")) {bias_participants <- cbind(bias_participants, temp)} 
  else {
    temp <- tibble(bias_prior = draws_df$bias_prior, bias_est = draws_df$bias)
    colnames(temp)[2] <- paste0("bias_est_", i)
    bias_participants <- temp}
  
  # prior_post_plots[[i]] <- ggplot(draws_df) +
  #   geom_density(aes(inv_logit_scaled(bias)), alpha = 0.6, fill = "lightblue") +
  #   geom_density(aes(inv_logit_scaled(bias_prior)), alpha = 0.6, fill = "pink") +
  #   theme_bw() +
  #   ggtitle(paste("Participant", i))
  #   # temp <- tibble(bias_est = mean(inv_logit_scaled(draws_df$bias)))
  #   # if (exists("recovery_df")) {recovery_df <- rbind(recovery_df, temp)} else {recovery_df <- temp}
  # 
  # cat_bias_plot[[i]] <- ggplot(draws_df, aes(.iteration, bias, group = .chain, color = .chain)) +
  # geom_line() +
  # theme_classic()

}

# prior_post_plots
# cat_bias_plot

bias_participants %>% 
  ggplot() +
  geom_density(aes(inv_logit_scaled(bias_est_1)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_2)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_3)), fill = "green", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_4)), fill = "lightblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_5)), fill = "darkblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_6)), fill = "yellow", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_7)), fill = "darkgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_8)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_9)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_10)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_11)), fill = "green", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_12)), fill = "lightblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_13)), fill = "darkblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_14)), fill = "yellow", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_15)), fill = "darkgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_16)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_17)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_18)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_19)), fill = "green", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_20)), fill = "lightblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_21)), fill = "darkblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_22)), fill = "yellow", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_23)), fill = "darkgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_24)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_25)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_26)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_27)), fill = "green", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_28)), fill = "lightblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_29)), fill = "darkblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_30)), fill = "yellow", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_31)), fill = "darkgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_32)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_33)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_34)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_35)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_36)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_37)), fill = "green", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_38)), fill = "lightblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_39)), fill = "darkblue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_40)), fill = "yellow", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_41)), fill = "darkgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_42)), fill = "lightgreen", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_43)), fill = "pink", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_est_44)), fill = "blue", alpha = 0.1) +
  geom_density(aes(inv_logit_scaled(bias_prior)), fill = "purple", alpha = 0.4) +
  xlab("Mean Bias") +
  ylab("Posterior Density") +
  theme_classic()
```


## Multi-level model

```{r compiling model}

# Compiling model
simple_multi_model <- cmdstan_model("simple_multi_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

```

### Parameter Recovery

```{r fake data}
SimpleBayes_f <- function(bias, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

# Looping through all the agents to generate the data.
d <- NULL
biasM_val <- 0.5
biasSD_val <- 0.5
agents <- 10
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(Source1 = Source1, Source2 = Source2)

for (agent in 1:agents) {
  
  bias <- rnorm(1, biasM, biasM)
  
  belief <- rep(NA, nrow(db))
  choice <- rep(NA, nrow(db))
  continuous <- rep(NA, nrow(db))
  discrete <- rep(NA, nrow(db))
  
  for (n in seq(nrow(db))) {
    
    belief[n] <- SimpleBayes_f(bias, db[n,1], db[n,2])
    choice[n] <- rbinom(1,1, belief[n])
  }
  
  temp <- tibble(agent, trial = seq(nrow(db)), source1 = db[,1], source2 = db[,2],  belief, choice, bias, biasM_val, biasSD_val, continuous, discrete)
  
  if (agent > 1) {
    d <- rbind(d, temp)
  } else{
    d <- temp
  }
  
}

df_first_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source1) %>%
  pivot_wider(values_from = source1, names_from = agent) %>% 
  select(-trial)

df_group_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source2) %>%
  pivot_wider(values_from = source2, names_from = agent) %>% 
  select(-trial)

df_second_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, choice) %>%
  pivot_wider(values_from = choice, names_from = agent) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (d %>% filter(agent == 1) %>% nrow()),
  subjects = n_distinct(d$agent),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- simple_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)

samples$summary()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(biasM), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasM_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasM_val) +
  xlab("BiasM (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

ggplot(draws_df) +
  geom_density(aes(biasSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasSD_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasSD_val) +
  xlab("BiasSD (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

samples$cmdstan_diagnose()

ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```

```{r compiling model}

# Compiling model
weighted_multi_model <- cmdstan_model("weighted_multi_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)

```

### Parameter Recovery

```{r fake data}
WeightedBayes_f <- function(bias, weight1, weight2, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + weight1 * logit_scaled(Source1) + weight2 * logit_scaled(Source2))
  # outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

# Looping through all the agents to generate the data.
d <- NULL
biasM_val <- 0.5
biasSD_val <- 0.5
agents <- 10
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(Source1 = Source1, Source2 = Source2)

for (agent in 1:agents) {
  
  bias <- rnorm(1, biasM, biasM)
  
  belief <- rep(NA, nrow(db))
  choice <- rep(NA, nrow(db))
  continuous <- rep(NA, nrow(db))
  discrete <- rep(NA, nrow(db))
  
  for (n in seq(nrow(db))) {
    
    belief[n] <- WeightedBayes_f(bias, db[n,1], db[n,2])
    choice[n] <- rbinom(1,1, belief[n])
  }
  
  temp <- tibble(agent, trial = seq(nrow(db)), source1 = db[,1], source2 = db[,2],  belief, choice, bias, biasM_val, biasSD_val, continuous, discrete)
  
  if (agent > 1) {
    d <- rbind(d, temp)
  } else{
    d <- temp
  }
  
}

df_first_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source1) %>%
  pivot_wider(values_from = source1, names_from = agent) %>% 
  select(-trial)

df_group_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source2) %>%
  pivot_wider(values_from = source2, names_from = agent) %>% 
  select(-trial)

df_second_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, choice) %>%
  pivot_wider(values_from = choice, names_from = agent) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (d %>% filter(agent == 1) %>% nrow()),
  subjects = n_distinct(d$agent),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- weighted_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)

samples$summary()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(biasM), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasM_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasM_val) +
  xlab("BiasM (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

ggplot(draws_df) +
  geom_density(aes(biasSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasSD_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasSD_val) +
  xlab("BiasSD (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

samples$cmdstan_diagnose()

ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```

### Parameter Recovery

```{r fake data}
SimpleBayes_f <- function(bias, Source1, Source2){
  
  outcome <- inv_logit_scaled(bias + logit_scaled(Source1) + logit_scaled(Source2))
  
  return(outcome)
}

# Looping through all the agents to generate the data.
d <- NULL
biasM_val <- 0.5
biasSD_val <- 0.5
agents <- 10
Source1 <- seq(0.1,0.9, 0.1)
Source2 <- seq(0.1,0.9, 0.1)

db <- expand.grid(Source1 = Source1, Source2 = Source2)

for (agent in 1:agents) {
  
  bias <- rnorm(1, biasM, biasM)
  
  belief <- rep(NA, nrow(db))
  choice <- rep(NA, nrow(db))
  continuous <- rep(NA, nrow(db))
  discrete <- rep(NA, nrow(db))
  
  for (n in seq(nrow(db))) {
    
    belief[n] <- SimpleBayes_f(bias, db[n,1], db[n,2])
    choice[n] <- rbinom(1,1, belief[n])
  }
  
  temp <- tibble(agent, trial = seq(nrow(db)), source1 = db[,1], source2 = db[,2],  belief, choice, bias, biasM_val, biasSD_val, continuous, discrete)
  
  if (agent > 1) {
    d <- rbind(d, temp)
  } else{
    d <- temp
  }
  
}

df_first_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source1) %>%
  pivot_wider(values_from = source1, names_from = agent) %>% 
  select(-trial)

df_group_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, source2) %>%
  pivot_wider(values_from = source2, names_from = agent) %>% 
  select(-trial)

df_second_rating <- d %>% 
  group_by(agent) %>% 
  select(trial, agent, choice) %>%
  pivot_wider(values_from = choice, names_from = agent) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (d %>% filter(agent == 1) %>% nrow()),
  subjects = n_distinct(d$agent),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- simple_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)

samples$summary()

draws_df <- as_draws_df(samples$draws())

ggplot(draws_df) +
  geom_density(aes(biasM), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasM_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasM_val) +
  xlab("BiasM (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

ggplot(draws_df) +
  geom_density(aes(biasSD), fill = "blue", alpha = 0.3) +
  geom_density(aes(biasSD_prior), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = biasSD_val) +
  xlab("BiasSD (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for Bias", subtitle = "Black line indicates true value")

samples$cmdstan_diagnose()

ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()
```

### Parameter Estimation

```{r data}
df_real <- read_csv("data/cogsci_clean.csv")

df_real <- df_real %>% 
  filter(GroupRating != 0) %>% 
  filter(ID != 27) %>% # participant with only 1 for second rating
  select(ID,FaceID, FirstRating, GroupRating, SecondRating) %>% 
  mutate(FirstRating_new = FirstRating/9, 
         GroupRating_new = GroupRating/9,
         # Choice = ifelse(SecondRating > 4, 1, 0)
         Choice = NA
         )

for (n in seq(nrow(df_real))) {
  df_real$Choice[n] <- rbinom(1,1, df_real$SecondRating[n]/9)
}

# the problem here is that the trial does not correspond to the same FaceID

df_first_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, FirstRating_new) %>%
  pivot_wider(values_from = FirstRating_new, names_from = ID) %>% 
  select(-trial)

df_group_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, GroupRating_new) %>%
  pivot_wider(values_from = GroupRating_new, names_from = ID) %>% 
  select(-trial)

df_second_rating <- df_real %>% 
  group_by(ID) %>% 
  mutate(trial = row_number()) %>% select(trial, ID, Choice) %>%
  pivot_wider(values_from = Choice, names_from = ID) %>% 
  select(-trial)

data_simpleBayes <- list(
  trials = (df_real %>% filter(ID == 1) %>% nrow()),
  subjects = n_distinct(df_real$ID),
  first_rating = as.matrix(df_first_rating),
  other_rating = as.matrix(df_group_rating),
  second_rating = as.matrix(df_second_rating)
  )

samples <- simple_multi_model$sample(
   data = data_simpleBayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh = 500,
   max_treedepth = 20,
   adapt_delta = 0.99,
)

samples$summary()
```

```{r model quality}
# Model quality check
draws_df <- as_draws_df(samples$draws())

samples$cmdstan_diagnose()

diagnostics_caterpillar_plot_biasm <- ggplot(draws_df, aes(.iteration, biasM, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

diagnostics_caterpillar_plot_biassd <- ggplot(draws_df, aes(.iteration, biasSD, group = .chain, color = .chain)) +
  geom_line() +
  theme_classic()

diagnostics_caterpillar_plot_biasm
diagnostics_caterpillar_plot_biassd

ggsave(filename = "figures/simple/caterpillar_biasM.png", plot = diagnostics_caterpillar_plot_biasm)

ggsave(filename = "figures/simple/caterpillar_biasSD.png", plot = diagnostics_caterpillar_plot_biassd)
```

```{r}
prior_post_biasm <- ggplot(draws_df) +
  geom_density(aes(inv_logit_scaled(biasM)), fill = "blue", alpha = 0.3) +
  geom_density(aes(inv_logit_scaled(biasM_prior)), fill = "red", alpha = 0.3) +
  geom_vline(xintercept = 0.5) +
  xlab("BiasM (Probability Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for BiasM", subtitle = "Black line indicates true value")

prior_post_biassd <- ggplot(draws_df) +
  geom_density(aes((biasSD)), fill = "blue", alpha = 0.3) +
  geom_density(aes((biasSD_prior)), fill = "red", alpha = 0.3) +
  # geom_vline(xintercept = 0.5) +
  xlab("BiasSD (Log Space)") +
  ylab("Estimate Densities") +
  theme_classic() +
  labs(title = "Prior and Posterior Distrbution for BiasSD", subtitle = "Black line indicates true value") +
  lims(x = c(0,1))

prior_post_biasm
prior_post_biassd

ggsave(filename = "figures/simple/prior_post_biasm.png", plot = prior_post_biasm)

ggsave(filename = "figures/simple/prior_post_biassd.png", plot = prior_post_biassd)
```



